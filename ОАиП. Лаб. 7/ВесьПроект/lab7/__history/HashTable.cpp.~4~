//---------------------------------------------------------------------------


#pragma hdrstop
#include "HashTable.h"

Table::Table()
{
	hashTable = new Zap[10];
}

int Table::h(int key)
{
	return key%10;
}

void Table::Add(Zap* data)
{

	if(!hashTable[h(data->key)].isFull)
	{
		hashTable[h(data->key)] = *data;
		hashTable[h(data->key)].isFull = true;
	}
	else
	{
		Zap* ceil = &hashTable[h(data->key)];
		while(ceil->next != NULL)
		{
			ceil = ceil->next;
		}
		ceil->next = data;
	}
}

Zap* Table::Find(int key)
{

	if(!hashTable[h(key)].isFull)
		return NULL;
	else
	{
		Zap* nxt = hashTable + h(key);
		while (nxt->next != NULL)
			nxt = nxt->next;
		return nxt;
	}
}

UnicodeString* Table::ToPrint()
{
	UnicodeString* strings = new UnicodeString[10];
	for(int i = 0; i < 10; i++)
	{
		strings[i] = "";
		if(!hashTable[i].isFull)
			continue;
		else
		{
			Zap* nxt = hashTable + i;
			strings[i] += IntToStr(nxt->key);
			while (nxt->next != NULL)
			{
				nxt = nxt->next;
				strings[i] += "   ";
				strings[i] += IntToStr(nxt->key);
			}
		}
	}
	return strings;

}

void Table::Cut(Table* &tb1, Table* &tb2, int num)
{
	for(int i = 0; i < 10; i++)
	{
		if(!hashTable[i].isFull)
			continue;
		else
		{
			Zap* nxt = hashTable + i;
			Zap* nxtFict = new Zap(nxt->key, nxt->info);
			nxt->key < num ? tb1->Add(nxtFict) : tb2->Add(nxtFict);

			while (nxt->next != NULL)
			{
				nxt = nxt->next;
				nxtFict = new Zap(nxt->key, nxt->info);
				nxt->key < num ? tb1->Add(nxtFict) : tb2->Add(nxtFict);
			}
		}
	}
}


#pragma package(smart_init)



