//---------------------------------------------------------------------------


#pragma hdrstop
#include "HashTable.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)

Table::Table()
{
	tbl = new Zap[10];
}

Zap::Zap()
{
	isFull = false;
	next = NULL;
}

Zap::Zap(int _key, int _info)
{
	key = _key;
	info = _info;
	next = NULL;
	isFull = true;
}



 int Table::h(int key)
 {
	return key%10;
 }

 void Table::Add(Zap* data)
 {
	if(!tbl[h(data->key)].isFull)
	{
		tbl[h(data->key)] = *data;
		tbl[h(data->key)].isFull = true;
	}
	else
	{
		Zap* nxt = &tbl[h(data->key)];
		while(nxt->next != NULL)
		{
			nxt = nxt->next;
		}
		nxt->next = data;
	}
 }

 Zap* Table::Find(int key)
 {

	if(!tbl[h(key)].isFull)
		return NULL;
	else
	{
		Zap* nxt = tbl + h(key);
		while (nxt->next != NULL)
			nxt = nxt->next;
		return nxt;
	}
 }

 UnicodeString* Table::ToPrint()
 {
	UnicodeString* strings = new UnicodeString[10];
	for(int i = 0; i < 10; i++)
	{
		strings[i] = "";
		if(!tbl[i].isFull)
			continue;
		else
		{
			Zap* nxt = tbl + i;
			strings[i] += IntToStr(nxt->key);
			while (nxt->next != NULL)
			{
				nxt = nxt->next;
				strings[i] += "   ";
				strings[i] += IntToStr(nxt->key);
			}
		}
	}
	return strings;

 }

 void Table::Cut(Table* &tb1, Table* &tb2, int num)
 {
	for(int i = 0; i < 10; i++)
	{
		if(!tbl[i].isFull)
			continue;
		else
		{
			Zap* nxt = tbl + i;
			Zap* nxtFict = new Zap(nxt->key, nxt->info);
			nxt->key < num ? tb1->Add(nxtFict) : tb2->Add(nxtFict);

			while (nxt->next != NULL)
			{
				nxt = nxt->next;
				nxtFict = new Zap(nxt->key, nxt->info);
				nxt->key < num ? tb1->Add(nxtFict) : tb2->Add(nxtFict);
			}
		}
	}
 }

